# 5_1001补题报告

该题使用状态转移求解即可，当时讲的三维dp基本没听懂，补题代码的思路为参考答案内的二维dp。当时没写出来还是因为找不出状态转移方程，不知道`f[i][j] = k`中的 $i$ $j$ $k$ 应该表示什么意思，对dp类题目十分不熟练，尝试寻找合理的 $i$ $j$ $k$ 应表示的量时花费了非常多的时间最后放弃。

## 核心代码：状态转移方程

```cpp
for (int i = 0; i < n; i++)
{
    int x;
    std::cin >> x;
    for (int j = x; j <= v; j++)
    {
        for (int k = m; k >= 1; k--)
            f[j][k] = (f[j][k] + f[j - x][k - 1]) % mod;
    }
}
```

其中`f[j][k]`存储的值为花费 $j$ 元且购买物品数为 $k$ 个时可能的购买方式数。最外层循环遍历所有种类的物品，并更新；中层循环 $j$ 遍历可能的总花费；最内层的 $k$ 遍历可能的购买总数。

最后取出所有购买了 $m$ 个物品的所有情况：
```cpp
for (int i = 1; i <= v; i++){
    ans = (ans + f[i][m]) % mod;
}
```

### 注意：

`f[0][0]`的需要设置为 $1$ 保证`f[j][1]`不为 $0$ ，整个状态转移数组不全为 $0$ 。

## 时间复杂度：

$O(TmnV)$